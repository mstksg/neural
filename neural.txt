-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | BP for FF ANNs
--   
--   BP for FF ANNs
@package neural
@version 0.1.0.0

module Data.Neural.HMatrix.FeedForward.Train

module Data.Neural.HMatrix.Utility
randomVec :: forall n m. (MonadRandom m, KnownNat n) => (Double, Double) -> m (R n)
randomMat :: forall f n m. (MonadRandom f, KnownNat n, KnownNat m) => (Double, Double) -> f (L n m)
randomVecMWC :: forall n m. (PrimMonad m, KnownNat n) => (Double, Double) -> Gen (PrimState m) -> m (R n)
randomMatMWC :: forall f n m. (PrimMonad f, KnownNat n, KnownNat m) => (Double, Double) -> Gen (PrimState f) -> f (L n m)

module Data.Neural.Activation
data NeuralActs :: * -> *
[NA] :: {naInternal :: a -> a, naOuter :: a -> a} -> NeuralActs a
data Activation :: *
[IdAct] :: Activation
[Logistic] :: Activation
[ReLU] :: Activation
[LReLU] :: !Rational -> Activation
[SoftPlus] :: Activation
[ScaledAct] :: !Rational -> !Activation -> Activation
[ExpandAct] :: !Rational -> !Activation -> Activation
data NASpec :: *
[NASpec] :: !Activation -> !Activation -> NASpec
reduceAct :: Activation -> Activation
toFunc :: (Floating a, Ord a) => Activation -> a -> a
toFunc' :: (Floating a, Ord a) => Activation -> a -> a
toNeuralActs :: (Floating a, Ord a) => NASpec -> NeuralActs a
toNeuralActs' :: (Floating a, Ord a) => NASpec -> NeuralActs a
logistic :: Floating a => a -> a
relu :: (Num a, Ord a) => a -> a
lRelu :: (Num a, Ord a) => a -> a -> a
softplus :: Floating a => a -> a
naLogId :: Floating a => NeuralActs a
naLogLog :: Floating a => NeuralActs a
naRLId :: (Num a, Ord a) => NeuralActs a
naRLRL :: (Num a, Ord a) => NeuralActs a
naRLLog :: (Floating a, Ord a) => NeuralActs a
naSPId :: Floating a => NeuralActs a
naSPSP :: Floating a => NeuralActs a
naUniform :: (a -> a) -> NeuralActs a
naWithId :: (a -> a) -> NeuralActs a
instance GHC.Generics.Generic Data.Neural.Activation.NASpec
instance GHC.Read.Read Data.Neural.Activation.NASpec
instance GHC.Classes.Eq Data.Neural.Activation.NASpec
instance GHC.Show.Show Data.Neural.Activation.NASpec
instance GHC.Generics.Generic Data.Neural.Activation.Activation
instance GHC.Read.Read Data.Neural.Activation.Activation
instance GHC.Classes.Eq Data.Neural.Activation.Activation
instance GHC.Show.Show Data.Neural.Activation.Activation
instance GHC.Generics.Generic (Data.Neural.Activation.NeuralActs a)
instance Data.Binary.Class.Binary Data.Neural.Activation.Activation
instance Data.Binary.Class.Binary Data.Neural.Activation.NASpec

module Data.Neural.Types

-- | Types
data Node :: Nat -> * -> *
[Node] :: {nodeBias :: !a, nodeWeights :: !(V i a)} -> Node i a
newtype FLayer :: Nat -> Nat -> * -> *
[FLayer] :: {layerNodes :: V o (Node i a)} -> FLayer i o a
data SomeFLayer :: * -> *
[SomeFLayer] :: (KnownNat i, KnownNat o) => FLayer i o a -> SomeFLayer a
data NetStruct :: *
[NetStruct] :: KnownNet i hs o => Proxy i -> NatList hs -> Proxy o -> NetStruct
type KnownNet i hs o = (KnownNat i, KnownNats hs, KnownNat o)
data NeuralActs :: * -> *
[NA] :: {naInternal :: a -> a, naOuter :: a -> a} -> NeuralActs a
data Activation :: *
[IdAct] :: Activation
[Logistic] :: Activation
[ReLU] :: Activation
[LReLU] :: !Rational -> Activation
[SoftPlus] :: Activation
[ScaledAct] :: !Rational -> !Activation -> Activation
[ExpandAct] :: !Rational -> !Activation -> Activation
data NASpec :: *
[NASpec] :: !Activation -> !Activation -> NASpec
tFLayerNodes :: Lens (FLayer i o a) (FLayer i' o' a) (V o (Node i a)) (V o' (Node i' a))
tNodeWeights :: Lens (Node i a) (Node i' a) (V i a) (V i' a)
instance GHC.Generics.Generic (Data.Neural.Types.FLayer a b c)
instance GHC.Base.Functor (Data.Neural.Types.FLayer a b)
instance Data.Traversable.Traversable (Data.Neural.Types.FLayer a b)
instance Data.Foldable.Foldable (Data.Neural.Types.FLayer a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Types.FLayer a b c)
instance GHC.Generics.Generic (Data.Neural.Types.Node a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Neural.Types.Node a b)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.Types.FLayer i o a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Types.SomeFLayer a)
instance GHC.Base.Functor Data.Neural.Types.SomeFLayer
instance Data.Foldable.Foldable Data.Neural.Types.SomeFLayer
instance Data.Traversable.Traversable Data.Neural.Types.SomeFLayer
instance (GHC.TypeLits.KnownNat i, System.Random.Random a) => System.Random.Random (Linear.V.V i a)
instance GHC.Base.Functor (Linear.V.V i) => GHC.Base.Functor (Data.Neural.Types.Node i)
instance GHC.Base.Applicative (Linear.V.V i) => GHC.Base.Applicative (Data.Neural.Types.Node i)
instance Linear.Vector.Additive (Linear.V.V i) => Linear.Vector.Additive (Data.Neural.Types.Node i)
instance Linear.Metric.Metric (Linear.V.V i) => Linear.Metric.Metric (Data.Neural.Types.Node i)
instance Data.Foldable.Foldable (Data.Neural.Types.Node i)
instance Data.Traversable.Traversable (Data.Neural.Types.Node i)
instance (GHC.TypeLits.KnownNat i, System.Random.Random a) => System.Random.Random (Data.Neural.Types.Node i a)
instance (GHC.TypeLits.KnownNat i, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Types.Node i a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Types.Node i a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Types.FLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Types.FLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Linear.Vector.Additive (Data.Neural.Types.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Types.FLayer i o)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.Types.SomeFLayer a)

module Data.Neural.Utility
unzipV :: V i (a, b) -> (V i a, V i b)
unzipV3 :: V i (a, b, c) -> (V i a, V i b, V i c)
vToR :: KnownNat n => V n Double -> R n
runFLayer :: (KnownNat i, Num a) => FLayer i o a -> V i a -> V o a
foldl'' :: NFData b => (b -> a -> b) -> b -> [a] -> b
netStructVal :: Integer -> [Integer] -> Integer -> Maybe NetStruct
reifyNetStruct :: Integer -> [Integer] -> Integer -> (forall i hs o. (KnownNat i, KnownNat o, KnownNats hs) => Proxy i -> NatList hs -> Proxy o -> r) -> r
fromNetStruct :: NetStruct -> (Integer, [Integer], Integer)
iterateN :: forall a. NFData a => (a -> a) -> a -> Int -> a
class Nudges w
nudges :: Nudges w => (a -> a) -> w a -> w (w a)
accumV :: (a -> b -> a) -> V n a -> [(Int, b)] -> V n a
deleteV :: Finite n -> V n a -> V (n - 1) a
snocV :: V n a -> a -> V (n + 1) a
deleteVec :: Int -> Vector a -> Vector a
processSeries :: forall a b n. KnownNat n => Vector (a, b) -> Vector (V n a, b)
instance forall k (n :: k). Linear.V.Dim n => Data.Neural.Utility.Nudges (Linear.V.V n)
instance Linear.V.Dim n => Data.Neural.Utility.Nudges (Data.Neural.Types.Node n)
instance (Linear.V.Dim i, Linear.V.Dim o) => Data.Neural.Utility.Nudges (Data.Neural.Types.FLayer i o)

module Data.Neural.FeedForward
data Network :: Nat -> [Nat] -> Nat -> * -> *
[NetOL] :: !(FLayer i o a) -> Network i '[] o a
[NetIL] :: KnownNat j => !(FLayer i j a) -> !(Network j hs o a) -> Network i (j : hs) o a
data SomeNet :: * -> *
[SomeNet] :: (KnownNat i, KnownNat o) => Network i hs o a -> SomeNet a
data OpaqueNet :: Nat -> Nat -> * -> *
[OpaqueNet] :: (KnownNat i, KnownNat o) => Network i hs o a -> OpaqueNet i o a
runNetwork :: forall i hs o a. (KnownNat i, Num a) => (a -> a) -> (a -> a) -> Network i hs o a -> V i a -> V o a
trainSample :: forall i o a hs. (KnownNat i, KnownNat o, Num a) => a -> (Forward a -> Forward a) -> (Forward a -> Forward a) -> V i a -> V o a -> Network i hs o a -> Network i hs o a
networkHeatmap :: (KnownNat i, Num a) => (a -> a) -> (a -> a) -> Network i hs o a -> V i a -> [[a]]
drawHeatmap :: KnownNat i => (Double -> Double) -> (Double -> Double) -> Network i hs o Double -> V i Double -> String
drawNetwork :: forall i hs o. Dim i => Network i hs o Double -> String
randomNetwork :: (RandomGen g, Random (Network i hs o a), Num a) => g -> (Network i hs o a, g)
randomNetworkIO :: (Random (Network i hs o a), Num a) => IO (Network i hs o a)
networkStructure :: forall i hs o a. (KnownNat i, KnownNat o) => Network i hs o a -> (Int, [Int], Int)

-- | Boilerplate instances
asOpaqueNet :: SomeNet a -> (forall i o. (KnownNat i, KnownNat o) => OpaqueNet i o a -> r) -> r
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.Network i hs o a)
instance Data.Foldable.Foldable (Data.Neural.FeedForward.Network i hs o)
instance Data.Traversable.Traversable (Data.Neural.FeedForward.Network i hs o)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.SomeNet a)
instance GHC.Base.Functor Data.Neural.FeedForward.SomeNet
instance Data.Foldable.Foldable Data.Neural.FeedForward.SomeNet
instance Data.Traversable.Traversable Data.Neural.FeedForward.SomeNet
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.FeedForward.OpaqueNet i o a)
instance GHC.Base.Functor (Data.Neural.FeedForward.OpaqueNet i o)
instance Data.Foldable.Foldable (Data.Neural.FeedForward.OpaqueNet i o)
instance Data.Traversable.Traversable (Data.Neural.FeedForward.OpaqueNet i o)
instance GHC.Base.Functor (Data.Neural.FeedForward.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.FeedForward.Network i '[] o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat j, GHC.Base.Applicative (Data.Neural.FeedForward.Network j hs o)) => GHC.Base.Applicative (Data.Neural.FeedForward.Network i (j : hs) o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.FeedForward.Network i '[] o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat j, System.Random.Random a, System.Random.Random (Data.Neural.FeedForward.Network j hs o a)) => System.Random.Random (Data.Neural.FeedForward.Network i (j : hs) o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.FeedForward.Network i '[] o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat j, Data.Binary.Class.Binary a, Data.Binary.Class.Binary (Data.Neural.FeedForward.Network j hs o a)) => Data.Binary.Class.Binary (Data.Neural.FeedForward.Network i (j : hs) o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.FeedForward.Network i hs o a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.FeedForward.SomeNet a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.FeedForward.OpaqueNet i o a)

module Data.Neural.HMatrix.FLayer
data FLayer :: Nat -> Nat -> *
[FLayer] :: {fLayerBiases :: !(R o), fLayerWeights :: !(L o i)} -> FLayer i o
data SomeFLayer :: *
[SomeFLayer] :: (KnownNat i, KnownNat o) => FLayer i o -> SomeFLayer
konstFLayer :: (KnownNat i, KnownNat o) => Double -> FLayer i o
runFLayer :: (KnownNat i, KnownNat o) => FLayer i o -> R i -> R o
fLayerFromHMat :: (KnownNat i, KnownNat o) => FLayer i o -> FLayer i o Double
fLayerFromV :: (KnownNat i, KnownNat o) => FLayer i o Double -> FLayer i o
randomFLayer :: forall m i o. (MonadRandom m, KnownNat i, KnownNat o) => (Double, Double) -> m (FLayer i o)
randomFLayerMWC :: forall m i o. (PrimMonad m, KnownNat i, KnownNat o) => (Double, Double) -> Gen (PrimState m) -> m (FLayer i o)
instance GHC.Generics.Generic (Data.Neural.HMatrix.FLayer.FLayer a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.FLayer.FLayer a b)
instance GHC.Show.Show Data.Neural.HMatrix.FLayer.SomeFLayer
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.FLayer.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.FLayer.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.FLayer.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => System.Random.Random (Data.Neural.HMatrix.FLayer.FLayer i o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.FLayer.FLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.FLayer.FLayer i o)
instance Data.Binary.Class.Binary Data.Neural.HMatrix.FLayer.SomeFLayer

module Data.Neural.HMatrix.FeedForward
data Network :: Nat -> [Nat] -> Nat -> *
[NetOL] :: !(FLayer i o) -> Network i '[] o
[NetIL] :: KnownNat j => !(FLayer i j) -> !(Network j hs o) -> Network i (j : hs) o
data SomeNet :: *
[SomeNet] :: (KnownNat i, KnownNat o) => Network i hs o -> SomeNet
data OpaqueNet :: Nat -> Nat -> *
[OpaqueNet] :: Network i hs o -> OpaqueNet i o
zipNet :: forall i hs o. (KnownNat i, KnownNat o) => (forall i' o'. (KnownNat i', KnownNat o') => FLayer i' o' -> FLayer i' o' -> FLayer i' o') -> Network i hs o -> Network i hs o -> Network i hs o
mapNet :: forall i hs o. (KnownNat i, KnownNat o) => (forall i' o'. (KnownNat i', KnownNat o') => FLayer i' o' -> FLayer i' o') -> Network i hs o -> Network i hs o
putNet :: (KnownNat i, KnownNat o) => Network i hs o -> Put
getNet :: (KnownNat i, KnownNat o) => Sing hs -> Get (Network i hs o)
hiddenSing :: forall i hs o. Network i hs o -> Sing hs
pureNet :: forall i hs o. (KnownNat i, KnownNat o, SingI hs) => (forall j k. (KnownNat j, KnownNat k) => FLayer j k) -> Network i hs o
runNetwork :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> R o
trainSample :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs (Forward Double) -> Double -> R i -> R o -> Network i hs o -> Network i hs o
traverseOpaqueNet :: Applicative f => (forall hs. Network i hs o -> f (Network i' hs o')) -> OpaqueNet i o -> f (OpaqueNet i' o')
mapOpaqueNet :: (forall hs. Network i hs o -> Network i' hs o') -> OpaqueNet i o -> OpaqueNet i' o'
randomNet :: forall m i hs o. (MonadRandom m, KnownNat i, KnownNat o, SingI hs) => (Double, Double) -> m (Network i hs o)
randomNetSing :: forall i hs o m. (KnownNat i, KnownNat o, MonadRandom m) => Sing hs -> (Double, Double) -> m (Network i hs o)
randomNetMWC :: forall m i hs o. (PrimMonad m, KnownNat i, KnownNat o, SingI hs) => (Double, Double) -> Gen (PrimState m) -> m (Network i hs o)
randomNetMWCSing :: forall m i hs o. (PrimMonad m, KnownNat i, KnownNat o) => Sing hs -> (Double, Double) -> Gen (PrimState m) -> m (Network i hs o)
randomONet :: (KnownNat i, KnownNat o, MonadRandom m) => [Integer] -> (Double, Double) -> m (OpaqueNet i o)
randomONetMWC :: (KnownNat i, KnownNat o, PrimMonad m) => [Integer] -> (Double, Double) -> Gen (PrimState m) -> m (OpaqueNet i o)
runOpaqueNet :: forall i o. (KnownNat i, KnownNat o) => NeuralActs Double -> OpaqueNet i o -> R i -> R o
traverseNet :: forall f i hs o. (Applicative f, KnownNat i, KnownNat o) => (forall m n. (KnownNat m, KnownNat n) => FLayer m n -> f (FLayer m n)) -> Network i hs o -> f (Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Show.Show (Data.Neural.HMatrix.FeedForward.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Show.Show (Data.Neural.HMatrix.FeedForward.OpaqueNet i o)
instance GHC.Show.Show Data.Neural.HMatrix.FeedForward.SomeNet
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Singletons.SingI hs) => GHC.Num.Num (Data.Neural.HMatrix.FeedForward.Network i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.FeedForward.Network i hs o)
instance (GHC.TypeLits.KnownNat i, Data.Singletons.SingI hs, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.FeedForward.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.FeedForward.OpaqueNet i o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.FeedForward.OpaqueNet i o)
instance Data.Binary.Class.Binary Data.Neural.HMatrix.FeedForward.SomeNet
instance Control.DeepSeq.NFData Data.Neural.HMatrix.FeedForward.SomeNet

module Data.Neural.HMatrix.FeedForward.Dropout
data NetMask :: Nat -> [Nat] -> Nat -> *
[MaskOL] :: NetMask i '[] o
[MaskIL] :: KnownNat j => !(R j) -> !(NetMask j js o) -> NetMask i (j : js) o
trainSampleDO :: forall i hs o m. (KnownNat i, KnownNat o, MonadRandom m) => NeuralActs (Forward Double) -> Double -> Double -> R i -> R o -> Network i hs o -> m (Network i hs o)
trainSampleDOMWC :: forall i hs o m. (KnownNat i, KnownNat o, PrimMonad m) => NeuralActs (Forward Double) -> Double -> Double -> R i -> R o -> Network i hs o -> Gen (PrimState m) -> m (Network i hs o)
trainStep :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs (Forward Double) -> Double -> R i -> R o -> Network i hs o -> Network i hs o
applyMask :: (KnownNat i, KnownNat o) => NetMask i hs o -> Network i hs o -> Network i hs o
genNetMask :: forall i hs o m. (SingI hs, MonadRandom m) => Double -> m (NetMask i hs o)
genNetMaskWith :: forall i hs o m. MonadRandom m => Double -> Network i hs o -> m (NetMask i hs o)
randomMask :: forall n m. (KnownNat n, MonadRandom m) => Double -> m (R n)
genNetMaskMWC :: forall i hs o m. (SingI hs, PrimMonad m) => Double -> Gen (PrimState m) -> m (NetMask i hs o)
genNetMaskWithMWC :: forall i hs o m. PrimMonad m => Double -> Network i hs o -> Gen (PrimState m) -> m (NetMask i hs o)
randomMaskMWC :: forall n m. (KnownNat n, PrimMonad m) => Double -> Gen (PrimState m) -> m (R n)
compensateDO :: forall i hs o. KnownNat o => Double -> Network i hs o -> Network i hs o
traverseNetMask :: forall f i hs o. Applicative f => (forall n. KnownNat n => R n -> f (R n)) -> NetMask i hs o -> f (NetMask i hs o)
instance GHC.Show.Show (Data.Neural.HMatrix.FeedForward.Dropout.NetMask i hs o)

module Data.Neural.Recurrent
data RNode :: Nat -> Nat -> * -> *
[RNode] :: {rNodeBias :: !a, rNodeIWeights :: !(V i a), rNodeSWeights :: !(V s a)} -> RNode i s a
data RLayer :: Nat -> Nat -> * -> *
[RLayer] :: {rLayerNodes :: !(V o (RNode i o a)), rLayerState :: !(V o a)} -> RLayer i o a
data Network :: Nat -> [Nat] -> Nat -> * -> *
[NetOL] :: !(FLayer i o a) -> Network i '[] o a
[NetIL] :: (KnownNat j, KnownNats hs) => !(RLayer i j a) -> !(Network j hs o a) -> Network i (j : hs) o a
data NetActs :: Nat -> [Nat] -> Nat -> * -> *
[NetAOL] :: !(V o a) -> NetActs i hs o a
[NetAIL] :: (KnownNat j, KnownNats hs) => !(V j a) -> !(NetActs j hs o a) -> NetActs i (j : js) o a
data SomeNet :: * -> *
[SomeNet] :: KnownNet i hs o => Network i hs o a -> SomeNet a
data OpaqueNet :: Nat -> Nat -> * -> *
[OpaqueNet] :: KnownNats hs => Network i hs o a -> OpaqueNet i o a
runRLayer :: forall i o a. (KnownNat i, KnownNat o, Num a) => (a -> a) -> RLayer i o a -> V i a -> (V o a, RLayer i o a)
runRLayerS :: forall i o a m. (KnownNat i, KnownNat o, Num a, MonadState (RLayer i o a) m) => (a -> a) -> V i a -> m (V o a)
netActsOut :: NetActs i hs o a -> V o a
runNetwork :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> Network i hs o a -> V i a -> (V o a, Network i hs o a)
runNetworkS :: (Num a, KnownNat i, MonadState (Network i hs o a) m) => NeuralActs a -> V i a -> m (V o a)
runNetworkActs :: forall i hs o a. (KnownNat i, Num a) => NeuralActs a -> Network i hs o a -> V i a -> (NetActs i hs o a, Network i hs o a)
runNetworkActsS :: forall i hs o m a. (KnownNat i, Num a, MonadState (Network i hs o a) m) => NeuralActs a -> V i a -> m (NetActs i hs o a)
runNetStream :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> Network i hs o a -> [V i a] -> ([V o a], Network i hs o a)
runNetStream_ :: forall i hs o a. (Num a, KnownNat i, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> [V o a]
prerunNetStream :: forall i hs o a. (Num a, KnownNat i, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> Network i hs o a
runNetStreamActs :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> Network i hs o a -> [V i a] -> ([NetActs i hs o a], Network i hs o a)
runNetStreamActs_ :: forall i hs o a. (Num a, KnownNat i, NFData a) => NeuralActs a -> Network i hs o a -> [V i a] -> [NetActs i hs o a]
runNetFeedback :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> (V o a -> V i a) -> Network i hs o a -> V i a -> [(V o a, Network i hs o a)]
runNetFeedback_ :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> (V o a -> V i a) -> Network i hs o a -> V i a -> [V o a]
runNetFeedbackM_ :: forall i hs o a m. (Num a, KnownNat i, Monad m) => NeuralActs a -> (V o a -> m (V i a)) -> Network i hs o a -> Int -> V i a -> m [V o a]
runNetActsFeedbackM_ :: forall i hs o m a. (Num a, KnownNat i, Monad m) => NeuralActs a -> (V o a -> m (V i a)) -> Network i hs o a -> Int -> V i a -> m [NetActs i hs o a]
randomNetwork :: (MonadRandom m, Random (Network i hs o a), Num a) => m (Network i hs o a)
randomNetwork' :: (KnownNet i hs o, MonadRandom m, Random (Network i hs o a), Num a) => m (Network i hs o a)
resetNetState :: forall i hs o a. (KnownNat o, KnownNat i, Num a) => Network i hs o a -> Network i hs o a

-- | Some traversals TODO: sharing with go
tNetRLayers :: (Applicative f, KnownNat o, KnownNat i) => (forall i' o'. (KnownNat i', KnownNat o') => RLayer i' o' a -> f (RLayer i' o' a)) -> Network i hs o a -> f (Network i hs o a)
tRLayerNodes :: Lens (RLayer i o a) (RLayer i' o a) (V o (RNode i o a)) (V o (RNode i' o a))
tRLayerState :: Lens' (RLayer i o a) (V o a)
tNetStates :: (Applicative f, KnownNat o, KnownNat i) => (forall h. KnownNat h => V h a -> f (V h a)) -> Network i hs o a -> f (Network i hs o a)
tNetOLayer :: (Functor f, KnownNat i) => (forall j. KnownNat j => FLayer j o a -> f (FLayer j o' a)) -> Network i hs o a -> f (Network i hs o' a)
tNetLayers :: (Applicative f, KnownNat i) => (forall j. KnownNat j => FLayer j o a -> f (FLayer j o' b)) -> (forall i' j. KnownNat j => RLayer i' j a -> f (RLayer i' j b)) -> Network i hs o a -> f (Network i hs o' b)
tRNodeSWeights :: Lens (RNode i s a) (RNode i s' a) (V s a) (V s' a)
tRNodeIWeights :: Lens (RNode i s a) (RNode i' s a) (V i a) (V i' a)
tRNodeWeights :: Lens' (RNode i s a) (V i a, V s a)

-- | Validating
seriesError :: (KnownNat i, KnownNat o, Num a, Traversable t) => NeuralActs a -> Network i hs o a -> t (V i a, V o a) -> (a, Network i hs o a)
seriesError_ :: (KnownNat i, KnownNat o, Num a, Traversable t) => NeuralActs a -> Network i hs o a -> t (V i a, V o a) -> a
seriesErrorS :: forall i hs o a t m. (KnownNat i, KnownNat o, Num a, MonadState (Network i hs o a) m, Traversable t) => NeuralActs a -> t (V i a, V o a) -> m a

-- | Boilerplate instances
asOpaqueNet :: SomeNet a -> (forall i o. (KnownNat i, KnownNat o) => OpaqueNet i o a -> r) -> r
instance GHC.Generics.Generic (Data.Neural.Recurrent.RLayer a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.RLayer a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.RLayer a b)
instance GHC.Base.Functor (Data.Neural.Recurrent.RLayer a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.RLayer a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.RNode a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.RNode a b)
instance GHC.Generics.Generic (Data.Neural.Recurrent.RNode a b c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.RNode a b c)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.Network i hs o a)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.Network i hs o)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.Network i hs o)
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.SomeNet a)
instance GHC.Base.Functor Data.Neural.Recurrent.SomeNet
instance Data.Foldable.Foldable Data.Neural.Recurrent.SomeNet
instance Data.Traversable.Traversable Data.Neural.Recurrent.SomeNet
instance GHC.Show.Show a => GHC.Show.Show (Data.Neural.Recurrent.OpaqueNet i o a)
instance GHC.Base.Functor (Data.Neural.Recurrent.OpaqueNet i o)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.OpaqueNet i o)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.OpaqueNet i o)
instance GHC.Base.Functor (Data.Neural.Recurrent.RNode i s)
instance (GHC.Base.Applicative (Linear.V.V i), GHC.Base.Applicative (Linear.V.V s)) => GHC.Base.Applicative (Data.Neural.Recurrent.RNode i s)
instance (Linear.Vector.Additive (Linear.V.V i), Linear.Vector.Additive (Linear.V.V s)) => Linear.Vector.Additive (Data.Neural.Recurrent.RNode i s)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.RNode i s a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.RNode i s a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.RNode i s a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.RLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Recurrent.RLayer i o)
instance (Data.Binary.Class.Binary a, GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.Recurrent.RLayer i o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.RLayer i o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.NetActs i hs o a)
instance GHC.Base.Functor (Data.Neural.Recurrent.Network i hs o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o) => Linear.Vector.Additive (Data.Neural.Recurrent.Network i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Network i hs o) => Linear.Metric.Metric (Data.Neural.Recurrent.Network i hs o)
instance (Data.Neural.Types.KnownNet i hs o, System.Random.Random a) => System.Random.Random (Data.Neural.Recurrent.Network i hs o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o, Type.Class.Known.Known (Data.Type.Product.Prod Data.Proxy.Proxy) hs, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.Network i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Network i hs o a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat s) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.RNode i s)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Neural.Utility.Nudges (Data.Neural.Recurrent.Network i hs o)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Data.Neural.Recurrent.SomeNet a)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o, Data.Binary.Class.Binary a) => Data.Binary.Class.Binary (Data.Neural.Recurrent.OpaqueNet i o a)

module Data.Neural.HMatrix.Recurrent
data RLayer :: Nat -> Nat -> *
[RLayer] :: {rLayerBiases :: !(R o), rLayerIWeights :: !(L o i), rLayerSWeights :: !(L o o), rLayerState :: !(R o)} -> RLayer i o
data Network :: Nat -> [Nat] -> Nat -> *
[NetOL] :: !(FLayer i o) -> Network i '[] o
[NetIL] :: (KnownNat j, KnownNats hs) => !(RLayer i j) -> !(Network j hs o) -> Network i (j : hs) o
data NetActs :: Nat -> [Nat] -> Nat -> *
[NetAOL] :: !(R o) -> NetActs i hs o
[NetAIL] :: (KnownNat j, KnownNats hs) => !(R j) -> !(NetActs j hs o) -> NetActs i (j : js) o
data SomeNet :: *
[SomeNet] :: KnownNet i hs o => Network i hs o -> SomeNet
data OpaqueNet :: Nat -> Nat -> *
[OpaqueNet] :: KnownNats hs => Network i hs o -> OpaqueNet i o
konstRLayer :: (KnownNat i, KnownNat o) => Double -> RLayer i o
pureNet :: forall i hs o. KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => FLayer j k) -> (forall j k. (KnownNat j, KnownNat k) => RLayer j k) -> Network i hs o
konstNet :: KnownNet i hs o => Double -> Network i hs o
zipNet :: forall i hs o. KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => FLayer j k -> FLayer j k -> FLayer j k) -> (forall j k. (KnownNat j, KnownNat k) => RLayer j k -> RLayer j k -> RLayer j k) -> Network i hs o -> Network i hs o -> Network i hs o
netActsOut :: NetActs i hs o -> R o
runRLayer :: (KnownNat i, KnownNat o) => (Double -> Double) -> RLayer i o -> R i -> (R o, RLayer i o)
runNetwork :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> (R o, Network i hs o)
runNetwork_ :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> R o
runNetworkS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m) => NeuralActs Double -> R i -> m (R o)
runNetworkActs :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> R i -> (NetActs i hs o, Network i hs o)
runNetworkActsS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m) => NeuralActs Double -> R i -> m (NetActs i hs o)
runNetStream :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> ([R o], Network i hs o)
runNetStream_ :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> [R o]
runNetStreamActs :: (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> ([NetActs i hs o], Network i hs o)
runNetStreamActs_ :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> Network i hs o -> [R i] -> [NetActs i hs o]
runNetFeedback :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [(R o, Network i hs o)]
runNetFeedback_ :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [R o]
runNetFeedbackM :: forall i hs o m. (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [(R o, Network i hs o)]
runNetFeedbackM_ :: forall i hs o m. (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [R o]
runNetActsFeedback :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [(NetActs i hs o, Network i hs o)]
runNetActsFeedback_ :: forall i hs o. (KnownNat i, KnownNat o) => NeuralActs Double -> (R o -> R i) -> Network i hs o -> R i -> [NetActs i hs o]
runNetActsFeedbackM :: forall i hs o m. (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [(NetActs i hs o, Network i hs o)]
runNetActsFeedbackM_ :: forall i hs o m. (KnownNat i, Monad m, KnownNat o) => NeuralActs Double -> (R o -> m (R i)) -> Network i hs o -> Int -> R i -> m [NetActs i hs o]
rLayerFromHMat :: (KnownNat i, KnownNat o) => RLayer i o -> RLayer i o Double
networkFromHMat :: KnownNet i hs o => Network i hs o -> Network i hs o Double
rLayerFromV :: (KnownNat i, KnownNat o) => RLayer i o Double -> RLayer i o
networkFromV :: KnownNet i hs o => Network i hs o Double -> Network i hs o
instance GHC.Generics.Generic (Data.Neural.HMatrix.Recurrent.RLayer a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.RLayer a b)
instance Data.Neural.Types.KnownNet i hs o => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.NetActs i hs o)
instance GHC.Show.Show Data.Neural.HMatrix.Recurrent.SomeNet
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.OpaqueNet i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.List.KnownNats hs, GHC.TypeLits.KnownNat o) => GHC.Real.Fractional (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.MonoTraversable.MonoFunctor (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => System.Random.Random (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Data.Neural.Types.KnownNet i hs o => System.Random.Random (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.NetActs i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.RLayer i o)
instance Data.Neural.Types.KnownNet i hs o => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.Network i hs o)
instance Data.Binary.Class.Binary Data.Neural.HMatrix.Recurrent.SomeNet
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => Data.Binary.Class.Binary (Data.Neural.HMatrix.Recurrent.OpaqueNet i o)

module Data.Neural.HMatrix.Recurrent.Train
trainSeries :: forall i hs o f. (KnownNet i hs o, Foldable f) => NeuralActs (Forward Double) -> Double -> Double -> R o -> f (R i) -> Network i hs o -> Network i hs o
trainStates :: forall i hs o. Double -> NetworkU i hs o -> NetStates i hs o -> Deltas i hs o -> Network i hs o
bptt :: forall i hs o f. (KnownNet i hs o, Foldable f) => NeuralActs (Forward Double) -> Double -> R o -> f (R i) -> NetStates i hs o -> NetworkU i hs o -> (Deltas i hs o, NetworkU i hs o)
toNetworkU :: Network i hs o -> (NetStates i hs o, NetworkU i hs o)
data RLayerU :: Nat -> Nat -> *
[RLayerU] :: {_rLayerUBiases :: !(R o), _rLayerUIWeights :: !(L o i), _rLayerUSWeights :: !(L o o)} -> RLayerU i o
data NetworkU :: Nat -> [Nat] -> Nat -> *
[NetUOL] :: !(FLayer i o) -> NetworkU i '[] o
[NetUIL] :: (KnownNat j, KnownNats hs) => !(RLayerU i j) -> !(NetworkU j hs o) -> NetworkU i (j : hs) o
data Deltas :: Nat -> [Nat] -> Nat -> *
[DeltasOL] :: !(R i) -> Deltas i '[] o
[DeltasIL] :: !(R i) -> !(R j) -> !(Deltas j hs o) -> Deltas i (j : hs) o
data NetStates :: Nat -> [Nat] -> Nat -> *
[NetSOL] :: NetStates i '[] o
[NetSIL] :: (KnownNat j, KnownNats hs) => !(R j) -> !(NetStates j hs o) -> NetStates i (j : hs) o
instance GHC.Generics.Generic (Data.Neural.HMatrix.Recurrent.Train.RLayerU a b)
instance (GHC.TypeLits.KnownNat a, GHC.TypeLits.KnownNat b) => GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Train.RLayerU a b)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.RLayerU i j)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.NetworkU i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.NetStates i hs o)
instance Control.DeepSeq.NFData (Data.Neural.HMatrix.Recurrent.Train.Deltas i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Train.RLayerU i o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Num.Num (Data.Neural.HMatrix.Recurrent.Train.NetworkU i hs o)

module Data.Neural.HMatrix.Recurrent.Dropout
trainSeriesDO :: forall i hs o m f. (KnownNet i hs o, MonadRandom m, Foldable f) => NeuralActs (Forward Double) -> Double -> Double -> Double -> R o -> f (R i) -> Network i hs o -> m (Network i hs o)
trainSeriesDOMWC :: forall i hs o m f. (KnownNet i hs o, PrimMonad m, Foldable f) => NeuralActs (Forward Double) -> Double -> Double -> Double -> R o -> f (R i) -> Network i hs o -> Gen (PrimState m) -> m (Network i hs o)
compensateDO :: forall i hs o. KnownNet i hs o => Double -> Network i hs o -> Network i hs o
instance GHC.Show.Show (Data.Neural.HMatrix.Recurrent.Dropout.NetMask i hs o)

module Data.Neural.HMatrix.Recurrent.Generate
randomFLayer :: forall m i o. (MonadRandom m, KnownNat i, KnownNat o) => (Double, Double) -> m (FLayer i o)
randomRLayer :: forall m i o. (MonadRandom m, KnownNat i, KnownNat o) => (Double, Double) -> m (RLayer i o)
randomNet :: forall m i hs o. (MonadRandom m, KnownNet i hs o) => (Double, Double) -> m (Network i hs o)
randomFLayerMWC :: forall m i o. (PrimMonad m, KnownNat i, KnownNat o) => (Double, Double) -> Gen (PrimState m) -> m (FLayer i o)
randomRLayerMWC :: forall m i o. (PrimMonad m, KnownNat i, KnownNat o) => (Double, Double) -> Gen (PrimState m) -> m (RLayer i o)
randomNetMWC :: forall m i hs o. (PrimMonad m, KnownNet i hs o) => (Double, Double) -> Gen (PrimState m) -> m (Network i hs o)

module Data.Neural.Recurrent.Dropout
compensateDO :: forall i hs o a. Fractional a => a -> Network i hs o a -> Network i hs o a

module Data.Neural.Recurrent.Modify
deleteLayer :: KnownNet i hs o => (forall j k. (KnownNat j, KnownNat k) => Node j a -> Node k a) -> (forall j k l. (KnownNat j, KnownNat k, KnownNat l) => RNode j l a -> RNode k l a) -> Fin (Len hs) -> Network i hs o a -> OpaqueNet i o a
addLayer :: (KnownNet i hs o, KnownNat l) => (forall j k. (KnownNat j, KnownNat k) => (RLayer j l a, FLayer l k a)) -> (forall j k. (KnownNat j, KnownNat k) => (RLayer j l a, RLayer l k a)) -> Fin (Len (i : hs)) -> Network i hs o a -> OpaqueNet i o a
deleteNode :: forall i hs h o a. KnownNet i hs o => Index hs h -> Finite h -> Network i hs o a -> OpaqueNet i o a
addNode :: forall i hs o a. KnownNet i hs o => (forall j l. (KnownNat j, KnownNat l, KnownNat (l + 1)) => (RNode j (l + 1) a, V l a, a)) -> (forall k. KnownNat k => V k a) -> Fin (Len hs) -> Network i hs o a -> OpaqueNet i o a

module Data.Neural.Recurrent.Train
newtype RLayerU :: Nat -> Nat -> * -> *
[RLayerU] :: {rLayerUNodes :: V o (RNode i o a)} -> RLayerU i o a
data NetworkU :: Nat -> [Nat] -> Nat -> * -> *
[NetUOL] :: !(FLayer i o a) -> NetworkU i '[] o a
[NetUIL] :: (KnownNat j, KnownNats hs) => !(RLayerU i j a) -> !(NetworkU j hs o a) -> NetworkU i (j : hs) o a
data Deltas :: Nat -> [Nat] -> Nat -> * -> *
[DeltasOL] :: !(V i a) -> Deltas i '[] o a
[DeltasIL] :: !(V i a) -> !(V j a) -> !(Deltas j hs o a) -> Deltas i (j : hs) o a
data NetStates :: Nat -> [Nat] -> Nat -> * -> *
[NetSOL] :: NetStates i '[] o a
[NetSIL] :: (KnownNat j, KnownNats hs) => !(V j a) -> !(NetStates j hs o a) -> NetStates i (j : hs) o a
runRLayerU :: forall i o a. (KnownNat i, KnownNat o, Num a) => (a -> a) -> RLayerU i o a -> V i a -> V o a -> (V o a, V o a)
runNetworkU :: forall i hs o a. (Num a, KnownNat i) => NeuralActs a -> NetworkU i hs o a -> V i a -> NetStates i hs o a -> (V o a, NetStates i hs o a)
tNetULayers :: forall i hs o o' a b f. (Applicative f) => (forall j. FLayer j o a -> f (FLayer j o' b)) -> (forall i' j. RLayerU i' j a -> f (RLayerU i' j b)) -> NetworkU i hs o a -> f (NetworkU i hs o' b)
toNetworkU :: Network i hs o a -> (NetStates i hs o a, NetworkU i hs o a)
trainSeries :: forall i hs o a f. (KnownNet i hs o, Fractional a, NFData a, Foldable f) => NeuralActs (Forward a) -> a -> a -> V o a -> f (V i a) -> Network i hs o a -> Network i hs o a

-- | Stochastic
nudgeNetworkN :: (MonadRandom m, Floating a, Random (Network i hs o a), Applicative (Network i hs o)) => a -> Network i hs o a -> m (Network i hs o a)
nudgeNetwork :: forall i hs o a m. (MonadRandom m, Num a, Random a) => a -> Network i hs o a -> m (Network i hs o a)
adjustNetwork :: (MonadRandom m, MonadState (Network i hs o a) m, Random a, Ord a, Floating a, KnownNat i, KnownNat o) => NeuralActs a -> (Network i hs o a -> m (Network i hs o a)) -> a -> Maybe a -> [(V i a, V o a)] -> m a
adjustNetworkGD :: forall i hs o a. (Applicative (Network i hs o), Floating a, KnownNat i, KnownNat o) => NeuralActs a -> a -> a -> [(V i a, V o a)] -> Network i hs o a -> Network i hs o a
trainSeriesSI :: forall i hs o a m. (MonadRandom m, MonadState (Network i hs o a) m, Floating a, Ord a, KnownNat i, KnownNat o, Random a) => NeuralActs a -> (Network i hs o a -> m (Network i hs o a)) -> a -> a -> [(V i a, V o a)] -> Int -> m ()
trainSeriesGD :: forall i hs o a. (Floating a, KnownNet i hs o, NFData a) => NeuralActs a -> a -> a -> [(V i a, V o a)] -> Network i hs o a -> Int -> Network i hs o a
instance GHC.Generics.Generic (Data.Neural.Recurrent.Train.RLayerU a b c)
instance Data.Traversable.Traversable (Data.Neural.Recurrent.Train.RLayerU a b)
instance Data.Foldable.Foldable (Data.Neural.Recurrent.Train.RLayerU a b)
instance GHC.Base.Functor (Data.Neural.Recurrent.Train.RLayerU a b)
instance GHC.Show.Show c => GHC.Show.Show (Data.Neural.Recurrent.Train.RLayerU a b c)
instance GHC.Base.Functor (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance (GHC.TypeLits.KnownNat i, GHC.TypeLits.KnownNat o) => GHC.Base.Applicative (Data.Neural.Recurrent.Train.RLayerU i o)
instance Data.Neural.Types.KnownNet i hs o => GHC.Base.Applicative (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance GHC.Base.Applicative (Data.Neural.Recurrent.Train.NetworkU i hs o) => Linear.Vector.Additive (Data.Neural.Recurrent.Train.NetworkU i hs o)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.NetworkU i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.RLayerU i j a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.NetStates i hs o a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Neural.Recurrent.Train.Deltas i hs o a)
