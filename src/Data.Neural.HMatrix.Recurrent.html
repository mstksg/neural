<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE BangPatterns         #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE DataKinds            #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase           #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE DeriveGeneric        #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE InstanceSigs         #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts     #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE GADTs                #-}</span><span>
</span><a name="line-8"></a><span class="hs-pragma">{-# LANGUAGE KindSignatures       #-}</span><span>
</span><a name="line-9"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables  #-}</span><span>
</span><a name="line-10"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes           #-}</span><span>
</span><a name="line-11"></a><span class="hs-pragma">{-# LANGUAGE StandaloneDeriving   #-}</span><span>
</span><a name="line-12"></a><span class="hs-pragma">{-# LANGUAGE TypeFamilies         #-}</span><span>
</span><a name="line-13"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators        #-}</span><span>
</span><a name="line-14"></a><span class="hs-pragma">{-# LANGUAGE ViewPatterns         #-}</span><span>
</span><a name="line-15"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans #-}</span><span>
</span><a name="line-16"></a><span>
</span><a name="line-17"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">HMatrix</span><span class="hs-operator">.</span><span class="hs-identifier">Recurrent</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-18"></a><span>
</span><a name="line-19"></a><span class="hs-comment">-- import qualified Data.Neural.Types         as N</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">DeepSeq</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Random</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">R</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">State</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Foldable</span><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">MonoTraversable</span><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Neural.HMatrix.FLayer.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">HMatrix</span><span class="hs-operator">.</span><span class="hs-identifier">FLayer</span></a><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Neural.HMatrix.Utility.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">HMatrix</span><span class="hs-operator">.</span><span class="hs-identifier">Utility</span></a><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><a href="Data.Neural.Types.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Types</span></a><span>            </span><span class="hs-special">(</span><a href="Data.Neural.Types.html#KnownNet"><span class="hs-identifier hs-type">KnownNet</span></a><span class="hs-special">,</span><span> </span><a href="Data.Neural.Activation.html#NeuralActs"><span class="hs-identifier hs-type">NeuralActs</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Proxy</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Reflection</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>                 </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">TypeLits</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">LinearAlgebra</span><span class="hs-operator">.</span><span class="hs-identifier">Static</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Binary</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">B</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Data.Neural.Recurrent.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Neural</span><span class="hs-operator">.</span><span class="hs-identifier">Recurrent</span></a><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">N</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">V</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Vector</span><span class="hs-operator">.</span><span class="hs-identifier">Generic</span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">VG</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Linear</span><span class="hs-operator">.</span><span class="hs-identifier">V</span><span>                     </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">L</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Numeric</span><span class="hs-operator">.</span><span class="hs-identifier">LinearAlgebra</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">H</span><span>
</span><a name="line-40"></a><span>
</span><a name="line-41"></a><span class="hs-keyword">data</span><span> </span><a name="RLayer"><a href="Data.Neural.HMatrix.Recurrent.html#RLayer"><span class="hs-identifier">RLayer</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Nat</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Nat</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator hs-type">*</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-42"></a><span>    </span><a name="RLayer"><a href="Data.Neural.HMatrix.Recurrent.html#RLayer"><span class="hs-identifier">RLayer</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">{</span><span> </span><a name="rLayerBiases"><a href="Data.Neural.HMatrix.Recurrent.html#rLayerBiases"><span class="hs-identifier">rLayerBiases</span></a></a><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">R</span><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">)</span><span>
</span><a name="line-43"></a><span>              </span><span class="hs-special">,</span><span> </span><a name="rLayerIWeights"><a href="Data.Neural.HMatrix.Recurrent.html#rLayerIWeights"><span class="hs-identifier">rLayerIWeights</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">L</span><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span> </span><a href="#local-1627595738"><span class="hs-identifier hs-type">i</span></a><span class="hs-special">)</span><span>
</span><a name="line-44"></a><span>              </span><span class="hs-special">,</span><span> </span><a name="rLayerSWeights"><a href="Data.Neural.HMatrix.Recurrent.html#rLayerSWeights"><span class="hs-identifier">rLayerSWeights</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">L</span><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">)</span><span>
</span><a name="line-45"></a><span>              </span><span class="hs-special">,</span><span> </span><a name="rLayerState"><a href="Data.Neural.HMatrix.Recurrent.html#rLayerState"><span class="hs-identifier">rLayerState</span></a></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="hs-identifier hs-type">R</span><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">)</span><span>
</span><a name="line-46"></a><span>              </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Neural.HMatrix.Recurrent.html#RLayer"><span class="hs-identifier hs-type">RLayer</span></a><span> </span><a href="#local-1627595738"><span class="hs-identifier hs-type">i</span></a><span> </span><a href="#local-1627595737"><span class="hs-identifier hs-type">o</span></a><span>
</span><a name="line-47"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-48"></a><span>
</span><a name="line-49"></a><span class="hs-keyword">data</span><span> </span><a name="Network"><a href="Data.Neural.HMatrix.Recurrent.html#Network"><span class="hs-identifier">Network</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Nat</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-type">Nat</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Nat</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-operator hs-type">*</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-50"></a><span>    </span><a name="NetOL"><a href="Data.Neural.HMatrix.Recurrent.html#NetOL"><span class="hs-identifier">NetOL</span></a></a><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><a href="Data.Neural.HMatrix.FLayer.html#FLayer"><span class="hs-identifier hs-type">FLayer</span></a><span> </span><a href="#local-1627595731"><span class="hs-identifier hs-type">i</span></a><span> </span><a href="#local-1627595732"><span class="hs-identifier hs-type">o</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.Neural.HMatrix.Recurrent.html#Network"><span class="hs-identifier hs-type">Network</span></a><span> </span><a href="#local-1627595731"><span class="hs-identifier hs-type">i</span></a><span> </span><span class="hs-char">'[] o
    NetIL :: (KnownNat j, KnownNats hs)
          =&gt; !(RLayer i j) -&gt; !(Network j hs o) -&gt; Network i (j ': hs) o

infixr 5 `NetIL`

data NetActs :: Nat -&gt; [Nat] -&gt; Nat -&gt; * where
    NetAOL :: !(R o) -&gt; NetActs i hs o
    NetAIL :: (KnownNat j, KnownNats hs) =&gt; !(R j) -&gt; !(NetActs j hs o) -&gt; NetActs i (j ': js) o

infixr 5 `NetAIL`

data SomeNet :: * where
    SomeNet :: KnownNet i hs o =&gt; Network i hs o -&gt; SomeNet

data OpaqueNet :: Nat -&gt; Nat -&gt; * where
    OpaqueNet :: KnownNats hs =&gt; Network i hs o -&gt; OpaqueNet i o

deriving instance KnownNet i hs o =&gt; Show (Network i hs o)
deriving instance KnownNet i hs o =&gt; Show (NetActs i hs o)
deriving instance Show SomeNet
deriving instance (KnownNat i, KnownNat o) =&gt; Show (OpaqueNet i o)

type instance Element (RLayer i o) = Double

instance (KnownNat i, KnownNat o) =&gt; MonoFunctor (RLayer i o) where
    omap f (RLayer b wI wS s) = RLayer (dvmap f b)
                                       (dmmap f wI)
                                       (dmmap f wS)
                                       (dvmap f s)

konstRLayer :: (KnownNat i, KnownNat o)
            =&gt; Double
            -&gt; RLayer i o
konstRLayer = RLayer &lt;$&gt; konst &lt;*&gt; konst &lt;*&gt; konst &lt;*&gt; konst

instance (KnownNat i, KnownNat o) =&gt; Num (RLayer i o) where
    RLayer b1 wI1 wS1 s1 + RLayer b2 wI2 wS2 s2 = RLayer (b1  + b2)
                                                         (wI1 + wI2)
                                                         (wS1 + wS2)
                                                         (s1  + s2)
    RLayer b1 wI1 wS1 s1 * RLayer b2 wI2 wS2 s2 = RLayer (b1  * b2)
                                                         (wI1 * wI2)
                                                         (wS1 * wS2)
                                                         (s1  * s2)
    RLayer b1 wI1 wS1 s1 - RLayer b2 wI2 wS2 s2 = RLayer (b1  - b2)
                                                         (wI1 - wI2)
                                                         (wS1 - wS2)
                                                         (s1  - s2)
    abs    = omap abs
    negate = omap negate
    signum = omap signum
    fromInteger = konstRLayer . fromInteger

instance (KnownNat i, KnownNat o) =&gt; Fractional (RLayer i o) where
    RLayer b1 wI1 wS1 s1 / RLayer b2 wI2 wS2 s2 = RLayer (b1  / b2)
                                                         (wI1 / wI2)
                                                         (wS1 / wS2)
                                                         (s1  / s2)
    recip (RLayer b wI wS s) = RLayer (recip b) (recip wI) (recip wS) (recip s)
    fromRational = konstRLayer . fromRational


pureNet :: forall i hs o. KnownNet i hs o
        =&gt; (forall j k. (KnownNat j, KnownNat k) =&gt; FLayer j k)
        -&gt; (forall j k. (KnownNat j, KnownNat k) =&gt; RLayer j k)
        -&gt; Network i hs o
pureNet lf lr = go natsList
  where
    go :: forall j js. KnownNat j =&gt; NatList js -&gt; Network j js o
    go nl = case nl of
           &#216;NL       -&gt; NetOL lf
           _ :&lt;# nl' -&gt; lr `NetIL` go nl'

konstNet :: KnownNet i hs o =&gt; Double -&gt; Network i hs o
konstNet x = pureNet (konstFLayer x) (konstRLayer x)

zipNet
    :: forall i hs o. KnownNet i hs o
    =&gt; (forall j k. (KnownNat j, KnownNat k) =&gt; FLayer j k -&gt; FLayer j k -&gt; FLayer j k)
    -&gt; (forall j k. (KnownNat j, KnownNat k) =&gt; RLayer j k -&gt; RLayer j k -&gt; RLayer j k)
    -&gt; Network i hs o -&gt; Network i hs o
    -&gt; Network i hs o
zipNet ff fr = go
  where
    go :: forall j js. KnownNet j js o =&gt; Network j js o -&gt; Network j js o -&gt; Network j js o
    go n1 n2 = case n1 of
                 NetOL l1 -&gt;
                   case n2 of
                     NetOL l2 -&gt; NetOL (ff l1 l2)
                 NetIL l1 n1' -&gt;
                   case n2 of
                     NetIL l2 n2' -&gt;
                       NetIL (fr l1 l2) (go n1' n2')

instance (KnownNat i, KnownNats hs, KnownNat o) =&gt; Num (Network i hs o) where
    (+)         = zipNet (+) (+)
    (-)         = zipNet (-) (-)
    (*)         = zipNet (*) (*)
    negate      = omap negate
    abs         = omap abs
    signum      = omap signum
    fromInteger = konstNet . fromInteger

instance (KnownNat i, KnownNats hs, KnownNat o) =&gt; Fractional (Network i hs o) where
    (/)          = zipNet (/) (/)
    recip        = omap recip
    fromRational = konstNet . fromRational

type instance Element (Network i hs o) = Double

instance (KnownNat i, KnownNat o) =&gt; MonoFunctor (Network i hs o) where
    omap f = \case NetOL l   -&gt; NetOL (omap f l)
                   NetIL l n -&gt; NetIL (omap f l) (omap f n)

instance (KnownNat i, KnownNat o) =&gt; Random (RLayer i o) where
    random = runRand $
        RLayer &lt;$&gt; randomVec (-1, 1)
               &lt;*&gt; randomMat (-1, 1)
               &lt;*&gt; randomMat (-1, 1)
               &lt;*&gt; randomVec (-1, 1)
    randomR  = error &quot;RLayer i o (randomR): Unimplemented&quot;

instance KnownNet i hs o =&gt; Random (Network i hs o) where
    random :: forall g. RandomGen g =&gt; g -&gt; (Network i hs o, g)
    random = runRand $ go natsList
      where
        go :: forall j js. KnownNat j
           =&gt; NatList js
           -&gt; Rand g (Network j js o)
        go nl = case nl of
                  &#216;NL       -&gt; NetOL &lt;$&gt; getRandom
                  _ :&lt;# nl' -&gt; NetIL &lt;$&gt; getRandom &lt;*&gt; go nl'
    randomR  = error &quot;Network i hs o (randomR): Unimplemented&quot;

instance NFData (RLayer i o)

instance NFData (Network i hs o) where
    rnf (NetOL (force -&gt; !_)) = ()
    rnf (NetIL (force -&gt; !_) (force -&gt; !_)) = ()

instance NFData (NetActs i hs o) where
    rnf (NetAOL (force -&gt; !_)) = ()
    rnf (NetAIL (force -&gt; !_) (force -&gt; !_)) = ()

instance (KnownNat i, KnownNat o) =&gt; B.Binary (RLayer i o) where

instance KnownNet i hs o =&gt; B.Binary (Network i hs o) where
    put (NetOL l)    = B.put l
    put (NetIL l n') = B.put l *&gt; B.put n'
    get = go natsList
      where
        go :: forall j js. KnownNat j
           =&gt; NatList js
           -&gt; B.Get (Network j js o)
        go nl = case nl of
                  &#216;NL       -&gt; NetOL &lt;$&gt; B.get
                  _ :&lt;# nl' -&gt; NetIL &lt;$&gt; B.get &lt;*&gt; go nl'

instance B.Binary SomeNet where
    put sn = case sn of
               SomeNet (n :: Network i hs o) -&gt; do
                 B.put $ natVal (Proxy :: Proxy i)
                 B.put $ natVal (Proxy :: Proxy o)
                 B.put $ OpaqueNet n
    get = do
      i &lt;- B.get
      o &lt;- B.get
      reifyNat i $ \(Proxy :: Proxy i) -&gt;
        reifyNat o $ \(Proxy :: Proxy o) -&gt; do
          oqn &lt;- B.get :: B.Get (OpaqueNet i o)
          return $ case oqn of
                     OpaqueNet n -&gt; SomeNet n

instance (KnownNat i, KnownNat o) =&gt; B.Binary (OpaqueNet i o) where
    put oqn = case oqn of
                OpaqueNet n -&gt; do
                  case n of
                    NetOL l -&gt; do
                      B.put True
                      B.put l
                    NetIL (l :: RLayer i j) (n' :: Network j js o) -&gt; do
                      B.put False
                      B.put $ natVal (Proxy :: Proxy j)
                      B.put l
                      B.put (OpaqueNet n')
    get = do
      isOL &lt;- B.get
      if isOL
        then do
          OpaqueNet . NetOL &lt;$&gt; B.get
        else do
          j &lt;- B.get
          reifyNat j $ \(Proxy :: Proxy j) -&gt; do
            l   &lt;- B.get :: B.Get (RLayer i j)
            nqo &lt;- B.get :: B.Get (OpaqueNet j o)
            return $ case nqo of
              OpaqueNet n -&gt; OpaqueNet $ l `NetIL` n

netActsOut :: NetActs i hs o -&gt; R o
netActsOut n = case n of
                 NetAIL _ n' -&gt; netActsOut n'
                 NetAOL l    -&gt; l

runRLayer :: (KnownNat i, KnownNat o)
          =&gt; (Double -&gt; Double)
          -&gt; RLayer i o
          -&gt; R i
          -&gt; (R o, RLayer i o)
runRLayer f l@(RLayer b wI wS s) v = (v', l { rLayerState = dvmap f v' })
  where
    v'       = b + wI #&gt; v + wS #&gt; s
{-# INLINE runRLayer #-}

runNetwork :: forall i hs o. (KnownNat i, KnownNat o)
           =&gt; NeuralActs Double
           -&gt; Network i hs o
           -&gt; R i
           -&gt; (R o, Network i hs o)
runNetwork (NA f g) = go
  where
    go :: forall i' hs'. KnownNat i'
       =&gt; Network i' hs' o
       -&gt; R i'
       -&gt; (R o, Network i' hs' o)
    go n v = case n of
               NetOL l    -&gt; (dvmap g (runFLayer l v), n)
               NetIL l nI -&gt; let (v' , l')  = runRLayer f l v
                                 (v'', nI') = go nI (dvmap f v')
                             in  (v'', NetIL l' nI')
{-# INLINE runNetwork #-}

runNetwork_ :: forall i hs o. (KnownNat i, KnownNat o)
            =&gt; NeuralActs Double
            -&gt; Network i hs o
            -&gt; R i
            -&gt; R o
runNetwork_ na n = fst . runNetwork na n
{-# INLINE runNetwork_ #-}

runNetworkS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m)
            =&gt; NeuralActs Double
            -&gt; R i
            -&gt; m (R o)
runNetworkS na v = state (\n -&gt; runNetwork na n v)
{-# INLINE runNetworkS #-}

runNetworkActs :: forall i hs o. (KnownNat i, KnownNat o)
               =&gt; NeuralActs Double
               -&gt; Network i hs o
               -&gt; R i
               -&gt; (NetActs i hs o, Network i hs o)
runNetworkActs (NA f g) = go
  where
    go :: forall i' hs'. KnownNat i'
       =&gt; Network i' hs' o
       -&gt; R i'
       -&gt; (NetActs i' hs' o, Network i' hs' o)
    go n v = case n of
               NetOL l    -&gt; (NetAOL (dvmap g (runFLayer l v)), n)
               NetIL l nI -&gt; let (v' , l') = runRLayer f l v
                                 vRes      = dvmap f v'
                                 (nA, nI') = go nI vRes
                             in  (NetAIL vRes nA, NetIL l' nI')
{-# INLINE runNetworkActs #-}

runNetworkActsS :: (KnownNat i, KnownNat o, MonadState (Network i hs o) m)
                =&gt; NeuralActs Double
                -&gt; R i
                -&gt; m (NetActs i hs o)
runNetworkActsS na v = state (\n -&gt; runNetworkActs na n v)
{-# INLINE runNetworkActsS #-}

runNetStream :: (KnownNat i, KnownNat o)
             =&gt; NeuralActs Double
             -&gt; Network i hs o
             -&gt; [R i]
             -&gt; ([R o], Network i hs o)
runNetStream na n vs = runState (mapM (runNetworkS na) vs) n
{-# INLINE runNetStream #-}

runNetStream_ :: forall i hs o. (KnownNat i, KnownNat o)
              =&gt; NeuralActs Double
              -&gt; Network i hs o
              -&gt; [R i]
              -&gt; [R o]
runNetStream_ na = go
  where
    go :: Network i hs o -&gt; [R i] -&gt; [R o]
    go n (v:vs) = let (u, n') = runNetwork na n v
                  in  u `deepseq` n' `deepseq` u : go n' vs
    go _ []     = []
{-# INLINE runNetStream_ #-}

runNetStreamActs :: (KnownNat i, KnownNat o)
                 =&gt; NeuralActs Double
                 -&gt; Network i hs o
                 -&gt; [R i]
                 -&gt; ([NetActs i hs o], Network i hs o)
runNetStreamActs na n vs = runState (mapM (runNetworkActsS na) vs) n
{-# INLINE runNetStreamActs #-}

runNetStreamActs_ :: forall i hs o. (KnownNat i, KnownNat o)
                  =&gt; NeuralActs Double
                  -&gt; Network i hs o
                  -&gt; [R i]
                  -&gt; [NetActs i hs o]
runNetStreamActs_ na = go
  where
    go :: Network i hs o -&gt; [R i] -&gt; [NetActs i hs o]
    go n (v:vs) = let (u, n') = runNetworkActs na n v
                  in  u `deepseq` n' `deepseq` u : go n' vs
    go _ []     = []
{-# INLINE runNetStreamActs_ #-}

runNetFeedback :: forall i hs o. (KnownNat i, KnownNat o)
               =&gt; NeuralActs Double
               -&gt; (R o -&gt; R i)
               -&gt; Network i hs o
               -&gt; R i
               -&gt; [(R o, Network i hs o)]
runNetFeedback na nxt = go
  where
    go :: Network i hs o -&gt; R i -&gt; [(R o, Network i hs o)]
    go n v = let res@(v', n') = runNetwork na n v
             in  res : go n' (nxt v')
{-# INLINE runNetFeedback #-}

runNetFeedback_ :: forall i hs o. (KnownNat i, KnownNat o)
                =&gt; NeuralActs Double
                -&gt; (R o -&gt; R i)
                -&gt; Network i hs o
                -&gt; R i
                -&gt; [R o]
runNetFeedback_ na nxt = go
  where
    go :: Network i hs o -&gt; R i -&gt; [R o]
    go n v = let (v', n') = runNetwork na n v
             in  v' : go n' (nxt v')
{-# INLINE runNetFeedback_ #-}

runNetFeedbackM :: forall i hs o m. (KnownNat i, Monad m, KnownNat o)
                =&gt; NeuralActs Double
                -&gt; (R o -&gt; m (R i))
                -&gt; Network i hs o
                -&gt; Int
                -&gt; R i
                -&gt; m [(R o, Network i hs o)]
runNetFeedbackM na nxt = go
  where
    go :: Network i hs o -&gt; Int -&gt; R i -&gt; m [(R o, Network i hs o)]
    go n i v | i &lt;= 0    = return []
             | otherwise = do
                 let vn'@(v', n') = runNetwork na n v
                 vsns &lt;- go n' (i - 1) =&lt;&lt; nxt v'
                 return $ vn' : vsns

runNetFeedbackM_ :: forall i hs o m. (KnownNat i, Monad m, KnownNat o)
                 =&gt; NeuralActs Double
                 -&gt; (R o -&gt; m (R i))
                 -&gt; Network i hs o
                 -&gt; Int
                 -&gt; R i
                 -&gt; m [R o]
runNetFeedbackM_ na nxt = go
  where
    go :: Network i hs o -&gt; Int -&gt; R i -&gt; m [R o]
    go n i v | i &lt;= 0    = return []
             | otherwise = do
                 let (v', n') = runNetwork na n v
                 vs &lt;- go n' (i - 1) =&lt;&lt; nxt v'
                 return $ v' : vs

runNetActsFeedback
    :: forall i hs o. (KnownNat i, KnownNat o)
    =&gt; NeuralActs Double
    -&gt; (R o -&gt; R i)
    -&gt; Network i hs o
    -&gt; R i
    -&gt; [(NetActs i hs o, Network i hs o)]
runNetActsFeedback na nxt = go
  where
    go :: Network i hs o -&gt; R i -&gt; [(NetActs i hs o, Network i hs o)]
    go n v = let res@(nacts, n') = runNetworkActs na n v
                 v' = netActsOut nacts
             in  res : go n' (nxt v')

runNetActsFeedback_
    :: forall i hs o. (KnownNat i, KnownNat o)
    =&gt; NeuralActs Double
    -&gt; (R o -&gt; R i)
    -&gt; Network i hs o
    -&gt; R i
    -&gt; [NetActs i hs o]
runNetActsFeedback_ na nxt = go
  where
    go :: Network i hs o -&gt; R i -&gt; [NetActs i hs o]
    go n v = let (nacts, n') = runNetworkActs na n v
                 v' = netActsOut nacts
             in  nacts : go n' (nxt v')

runNetActsFeedbackM
    :: forall i hs o m. (KnownNat i, Monad m, KnownNat o)
    =&gt; NeuralActs Double
    -&gt; (R o -&gt; m (R i))
    -&gt; Network i hs o
    -&gt; Int
    -&gt; R i
    -&gt; m [(NetActs i hs o, Network i hs o)]
runNetActsFeedbackM na nxt = go
  where
    go :: Network i hs o -&gt; Int -&gt; R i -&gt; m [(NetActs i hs o, Network i hs o)]
    go n i v | i &lt;= 0    = return []
             | otherwise = do
                 let res@(nacts, n') = runNetworkActs na n v
                     v' = netActsOut nacts
                 vsns &lt;- go n' (i - 1) =&lt;&lt; nxt v'
                 return $ res : vsns

runNetActsFeedbackM_
    :: forall i hs o m. (KnownNat i, Monad m, KnownNat o)
    =&gt; NeuralActs Double
    -&gt; (R o -&gt; m (R i))
    -&gt; Network i hs o
    -&gt; Int
    -&gt; R i
    -&gt; m [NetActs i hs o]
runNetActsFeedbackM_ na nxt = go
  where
    go :: Network i hs o -&gt; Int -&gt; R i -&gt; m [NetActs i hs o]
    go n i v | i &lt;= 0    = return []
             | otherwise = do
                 let (nacts, n') = runNetworkActs na n v
                     v' = netActsOut nacts
                 ns &lt;- go n' (i - 1) =&lt;&lt; nxt v'
                 return $ nacts : ns


rLayerFromHMat :: (KnownNat i, KnownNat o) =&gt; RLayer i o -&gt; N.RLayer i o Double
rLayerFromHMat (RLayer b wI wS s) = N.RLayer (L.V . V.fromList $ zipWith3 N.RNode bl wIl wSl)
                                             (L.V sv)
  where
    bl = H.toList (extract b)
    sv = VG.convert (extract s)
    wIl = map (L.V . VG.convert . extract) $ toRows wI
    wSl = map (L.V . VG.convert . extract) $ toRows wS

networkFromHMat :: KnownNet i hs o =&gt; Network i hs o -&gt; N.Network i hs o Double
networkFromHMat n = case n of
                      NetOL l    -&gt; N.NetOL (fLayerFromHMat l)
                      NetIL l n' -&gt; rLayerFromHMat l `N.NetIL` networkFromHMat n'

rLayerFromV :: (KnownNat i, KnownNat o) =&gt; N.RLayer i o Double -&gt; RLayer i o
rLayerFromV (N.RLayer n s0) = RLayer b wI wS s
  where
    Just b = create . VG.convert . L.toVector $ N.rNodeBias &lt;$&gt; n
    Just wI = create . H.fromRows . toList $ VG.convert . L.toVector . N.rNodeIWeights &lt;$&gt; n
    Just wS = create . H.fromRows . toList $ VG.convert . L.toVector . N.rNodeSWeights &lt;$&gt; n
    Just s = create . VG.convert . L.toVector $ s0

networkFromV :: KnownNet i hs o =&gt; N.Network i hs o Double -&gt; Network i hs o
networkFromV n = case n of
                   N.NetOL l    -&gt; NetOL (fLayerFromV l)
                   N.NetIL l n' -&gt; rLayerFromV l `NetIL` networkFromV n'
</span></pre></body></html>